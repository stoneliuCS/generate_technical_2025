// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeIDAliensGetInternalServerError from json.
func (s *APIV1ChallengeIDAliensGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeIDAliensGetInternalServerError) {
					name = jsonFieldsNameOfAPIV1ChallengeIDAliensGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Waves != nil {
			e.FieldStart("waves")
			e.ArrStart()
			for _, elem := range s.Waves {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AlienTypes.Set {
			e.FieldStart("alienTypes")
			s.AlienTypes.Encode(e)
		}
	}
	{
		if s.Budget.Set {
			e.FieldStart("budget")
			s.Budget.Encode(e)
		}
	}
	{
		if s.WallDurability.Set {
			e.FieldStart("wallDurability")
			s.WallDurability.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOK = [4]string{
	0: "waves",
	1: "alienTypes",
	2: "budget",
	3: "wallDurability",
}

// Decode decodes APIV1ChallengeIDAliensGetOK from json.
func (s *APIV1ChallengeIDAliensGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "waves":
			if err := func() error {
				s.Waves = make([]APIV1ChallengeIDAliensGetOKWavesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeIDAliensGetOKWavesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Waves = append(s.Waves, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"waves\"")
			}
		case "alienTypes":
			if err := func() error {
				s.AlienTypes.Reset()
				if err := s.AlienTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alienTypes\"")
			}
		case "budget":
			if err := func() error {
				s.Budget.Reset()
				if err := s.Budget.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget\"")
			}
		case "wallDurability":
			if err := func() error {
				s.WallDurability.Reset()
				if err := s.WallDurability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wallDurability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOKAlienTypes) encodeFields(e *jx.Encoder) {
	{
		if s.Regular.Set {
			e.FieldStart("regular")
			s.Regular.Encode(e)
		}
	}
	{
		if s.Swift.Set {
			e.FieldStart("swift")
			s.Swift.Encode(e)
		}
	}
	{
		if s.Boss.Set {
			e.FieldStart("boss")
			s.Boss.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKAlienTypes = [3]string{
	0: "regular",
	1: "swift",
	2: "boss",
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypes from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "regular":
			if err := func() error {
				s.Regular.Reset()
				if err := s.Regular.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regular\"")
			}
		case "swift":
			if err := func() error {
				s.Swift.Reset()
				if err := s.Swift.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swift\"")
			}
		case "boss":
			if err := func() error {
				s.Boss.Reset()
				if err := s.Boss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOKAlienTypes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBoss) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBoss) encodeFields(e *jx.Encoder) {
	{
		if s.Hp.Set {
			e.FieldStart("hp")
			s.Hp.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Atk.Set {
			e.FieldStart("atk")
			s.Atk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKAlienTypesBoss = [3]string{
	0: "hp",
	1: "id",
	2: "atk",
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBoss from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBoss) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesBoss to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hp":
			if err := func() error {
				s.Hp.Reset()
				if err := s.Hp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "atk":
			if err := func() error {
				s.Atk.Reset()
				if err := s.Atk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOKAlienTypesBoss")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBoss) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBoss) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBossAtk as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesBossAtk) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBossAtk from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBossAtk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesBossAtk to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesBossAtk(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesBossAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBossAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBossHp as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesBossHp) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBossHp from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBossHp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesBossHp to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesBossHp(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesBossHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBossHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBossID as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesBossID) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBossID from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBossID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesBossID to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesBossID(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesBossID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesBossID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegular) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegular) encodeFields(e *jx.Encoder) {
	{
		if s.Hp.Set {
			e.FieldStart("hp")
			s.Hp.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Atk.Set {
			e.FieldStart("atk")
			s.Atk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKAlienTypesRegular = [3]string{
	0: "hp",
	1: "id",
	2: "atk",
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegular from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegular) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesRegular to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hp":
			if err := func() error {
				s.Hp.Reset()
				if err := s.Hp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "atk":
			if err := func() error {
				s.Atk.Reset()
				if err := s.Atk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOKAlienTypesRegular")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegular) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegular) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegularHp as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesRegularHp) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegularHp from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegularHp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesRegularHp to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesRegularHp(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesRegularHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegularHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegularID as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesRegularID) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegularID from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegularID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesRegularID to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesRegularID(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesRegularID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesRegularID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwift) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwift) encodeFields(e *jx.Encoder) {
	{
		if s.Hp.Set {
			e.FieldStart("hp")
			s.Hp.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Atk.Set {
			e.FieldStart("atk")
			s.Atk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKAlienTypesSwift = [3]string{
	0: "hp",
	1: "id",
	2: "atk",
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwift from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwift) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesSwift to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hp":
			if err := func() error {
				s.Hp.Reset()
				if err := s.Hp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "atk":
			if err := func() error {
				s.Atk.Reset()
				if err := s.Atk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOKAlienTypesSwift")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwift) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwift) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftID as json.
func (s APIV1ChallengeIDAliensGetOKAlienTypesSwiftID) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftID from json.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwiftID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKAlienTypesSwiftID to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKAlienTypesSwiftID(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKAlienTypesSwiftID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKAlienTypesSwiftID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKBudget as json.
func (s APIV1ChallengeIDAliensGetOKBudget) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKBudget from json.
func (s *APIV1ChallengeIDAliensGetOKBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKBudget to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKBudget(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKWallDurability as json.
func (s APIV1ChallengeIDAliensGetOKWallDurability) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKWallDurability from json.
func (s *APIV1ChallengeIDAliensGetOKWallDurability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKWallDurability to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeIDAliensGetOKWallDurability(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKWallDurability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKWallDurability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOKWavesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Aliens != nil {
			e.FieldStart("aliens")
			e.ArrStart()
			for _, elem := range s.Aliens {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKWavesItem = [1]string{
	0: "aliens",
}

// Decode decodes APIV1ChallengeIDAliensGetOKWavesItem from json.
func (s *APIV1ChallengeIDAliensGetOKWavesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKWavesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aliens":
			if err := func() error {
				s.Aliens = make([]APIV1ChallengeIDAliensGetOKWavesItemAliensItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeIDAliensGetOKWavesItemAliensItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Aliens = append(s.Aliens, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOKWavesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKWavesItemAliensItem = [2]string{
	0: "type",
	1: "count",
}

// Decode decodes APIV1ChallengeIDAliensGetOKWavesItemAliensItem from json.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKWavesItemAliensItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetOKWavesItemAliensItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKWavesItemAliensItem) {
					name = jsonFieldsNameOfAPIV1ChallengeIDAliensGetOKWavesItemAliensItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKWavesItemAliensItemType as json.
func (s APIV1ChallengeIDAliensGetOKWavesItemAliensItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APIV1ChallengeIDAliensGetOKWavesItemAliensItemType from json.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetOKWavesItemAliensItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APIV1ChallengeIDAliensGetOKWavesItemAliensItemType(v) {
	case APIV1ChallengeIDAliensGetOKWavesItemAliensItemTypeRegular:
		*s = APIV1ChallengeIDAliensGetOKWavesItemAliensItemTypeRegular
	case APIV1ChallengeIDAliensGetOKWavesItemAliensItemTypeSwift:
		*s = APIV1ChallengeIDAliensGetOKWavesItemAliensItemTypeSwift
	case APIV1ChallengeIDAliensGetOKWavesItemAliensItemTypeBoss:
		*s = APIV1ChallengeIDAliensGetOKWavesItemAliensItemTypeBoss
	default:
		*s = APIV1ChallengeIDAliensGetOKWavesItemAliensItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDAliensGetOKWavesItemAliensItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetOKWavesItemAliensItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDAliensGetUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDAliensGetUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDAliensGetUnauthorized = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeIDAliensGetUnauthorized from json.
func (s *APIV1ChallengeIDAliensGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDAliensGetUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDAliensGetUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeIDAliensGetUnauthorized) {
					name = jsonFieldsNameOfAPIV1ChallengeIDAliensGetUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDAliensGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDAliensGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostBadRequest = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeIDSubmitPostBadRequest from json.
func (s *APIV1ChallengeIDSubmitPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeIDSubmitPostBadRequest) {
					name = jsonFieldsNameOfAPIV1ChallengeIDSubmitPostBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeIDSubmitPostInternalServerError from json.
func (s *APIV1ChallengeIDSubmitPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeIDSubmitPostInternalServerError) {
					name = jsonFieldsNameOfAPIV1ChallengeIDSubmitPostInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDSubmitPostOK as json.
func (s APIV1ChallengeIDSubmitPostOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case APIV1ChallengeIDSubmitPostOK0APIV1ChallengeIDSubmitPostOK:
		s.APIV1ChallengeIDSubmitPostOK0.Encode(e)
	case APIV1ChallengeIDSubmitPostOK1APIV1ChallengeIDSubmitPostOK:
		s.APIV1ChallengeIDSubmitPostOK1.Encode(e)
	}
}

func (s APIV1ChallengeIDSubmitPostOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case APIV1ChallengeIDSubmitPostOK0APIV1ChallengeIDSubmitPostOK:
		s.APIV1ChallengeIDSubmitPostOK0.encodeFields(e)
	case APIV1ChallengeIDSubmitPostOK1APIV1ChallengeIDSubmitPostOK:
		s.APIV1ChallengeIDSubmitPostOK1.encodeFields(e)
	}
}

// Decode decodes APIV1ChallengeIDSubmitPostOK from json.
func (s *APIV1ChallengeIDSubmitPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "score":
				match := APIV1ChallengeIDSubmitPostOK0APIV1ChallengeIDSubmitPostOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "reason":
				match := APIV1ChallengeIDSubmitPostOK1APIV1ChallengeIDSubmitPostOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case APIV1ChallengeIDSubmitPostOK0APIV1ChallengeIDSubmitPostOK:
		if err := s.APIV1ChallengeIDSubmitPostOK0.Decode(d); err != nil {
			return err
		}
	case APIV1ChallengeIDSubmitPostOK1APIV1ChallengeIDSubmitPostOK:
		if err := s.APIV1ChallengeIDSubmitPostOK1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDSubmitPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostOK0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostOK0) encodeFields(e *jx.Encoder) {
	{
		if s.Valid.Set {
			e.FieldStart("valid")
			s.Valid.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostOK0 = [2]string{
	0: "valid",
	1: "score",
}

// Decode decodes APIV1ChallengeIDSubmitPostOK0 from json.
func (s *APIV1ChallengeIDSubmitPostOK0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostOK0 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			if err := func() error {
				s.Valid.Reset()
				if err := s.Valid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostOK0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostOK0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostOK0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostOK1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostOK1) encodeFields(e *jx.Encoder) {
	{
		if s.Valid.Set {
			e.FieldStart("valid")
			s.Valid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostOK1 = [2]string{
	0: "valid",
	1: "reason",
}

// Decode decodes APIV1ChallengeIDSubmitPostOK1 from json.
func (s *APIV1ChallengeIDSubmitPostOK1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostOK1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			if err := func() error {
				s.Valid.Reset()
				if err := s.Valid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostOK1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostOK1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostOK1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostReq) encodeFields(e *jx.Encoder) {
	{
		if s.GunsPurchased != nil {
			e.FieldStart("gunsPurchased")
			e.ArrStart()
			for _, elem := range s.GunsPurchased {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalCost.Set {
			e.FieldStart("totalCost")
			s.TotalCost.Encode(e)
		}
	}
	{
		if s.Assignments != nil {
			e.FieldStart("assignments")
			e.ArrStart()
			for _, elem := range s.Assignments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostReq = [3]string{
	0: "gunsPurchased",
	1: "totalCost",
	2: "assignments",
}

// Decode decodes APIV1ChallengeIDSubmitPostReq from json.
func (s *APIV1ChallengeIDSubmitPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gunsPurchased":
			if err := func() error {
				s.GunsPurchased = make([]APIV1ChallengeIDSubmitPostReqGunsPurchasedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeIDSubmitPostReqGunsPurchasedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GunsPurchased = append(s.GunsPurchased, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gunsPurchased\"")
			}
		case "totalCost":
			if err := func() error {
				s.TotalCost.Reset()
				if err := s.TotalCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCost\"")
			}
		case "assignments":
			if err := func() error {
				s.Assignments = make([]APIV1ChallengeIDSubmitPostReqAssignmentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeIDSubmitPostReqAssignmentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assignments = append(s.Assignments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostReqAssignmentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostReqAssignmentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Wave.Set {
			e.FieldStart("wave")
			s.Wave.Encode(e)
		}
	}
	{
		if s.GunQueues != nil {
			e.FieldStart("gunQueues")
			e.ArrStart()
			for _, elem := range s.GunQueues {
				e.ArrStart()
				for _, elem := range elem {
					e.Int(elem)
				}
				e.ArrEnd()
			}
			e.ArrEnd()
		}
	}
	{
		if s.WallDurabilityRemaining.Set {
			e.FieldStart("wallDurabilityRemaining")
			s.WallDurabilityRemaining.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostReqAssignmentsItem = [3]string{
	0: "wave",
	1: "gunQueues",
	2: "wallDurabilityRemaining",
}

// Decode decodes APIV1ChallengeIDSubmitPostReqAssignmentsItem from json.
func (s *APIV1ChallengeIDSubmitPostReqAssignmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostReqAssignmentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "wave":
			if err := func() error {
				s.Wave.Reset()
				if err := s.Wave.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wave\"")
			}
		case "gunQueues":
			if err := func() error {
				s.GunQueues = make([][]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []int
					elem = make([]int, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem int
						v, err := d.Int()
						elemElem = int(v)
						if err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.GunQueues = append(s.GunQueues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gunQueues\"")
			}
		case "wallDurabilityRemaining":
			if err := func() error {
				s.WallDurabilityRemaining.Reset()
				if err := s.WallDurabilityRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wallDurabilityRemaining\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostReqAssignmentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostReqAssignmentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostReqAssignmentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeIDSubmitPostReqGunsPurchasedItem = [1]string{
	0: "type",
}

// Decode decodes APIV1ChallengeIDSubmitPostReqGunsPurchasedItem from json.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostReqGunsPurchasedItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeIDSubmitPostReqGunsPurchasedItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType as json.
func (s APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType from json.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType(v) {
	case APIV1ChallengeIDSubmitPostReqGunsPurchasedItemTypeTurret:
		*s = APIV1ChallengeIDSubmitPostReqGunsPurchasedItemTypeTurret
	case APIV1ChallengeIDSubmitPostReqGunsPurchasedItemTypeMachineGun:
		*s = APIV1ChallengeIDSubmitPostReqGunsPurchasedItemTypeMachineGun
	case APIV1ChallengeIDSubmitPostReqGunsPurchasedItemTypeRayGun:
		*s = APIV1ChallengeIDSubmitPostReqGunsPurchasedItemTypeRayGun
	default:
		*s = APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberGetBadRequest = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberGetBadRequest from json.
func (s *APIV1MemberGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetBadRequest) {
					name = jsonFieldsNameOfAPIV1MemberGetBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberGetInternalServerError from json.
func (s *APIV1MemberGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetInternalServerError) {
					name = jsonFieldsNameOfAPIV1MemberGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberGetNotFound = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberGetNotFound from json.
func (s *APIV1MemberGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetNotFound) {
					name = jsonFieldsNameOfAPIV1MemberGetNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfAPIV1MemberGetOK = [1]string{
	0: "id",
}

// Decode decodes APIV1MemberGetOK from json.
func (s *APIV1MemberGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetOK) {
					name = jsonFieldsNameOfAPIV1MemberGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostBadRequest = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberRegisterPostBadRequest from json.
func (s *APIV1MemberRegisterPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostBadRequest) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostConflict = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberRegisterPostConflict from json.
func (s *APIV1MemberRegisterPostConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostConflict) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostCreated = [1]string{
	0: "id",
}

// Decode decodes APIV1MemberRegisterPostCreated from json.
func (s *APIV1MemberRegisterPostCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostCreated) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberRegisterPostInternalServerError from json.
func (s *APIV1MemberRegisterPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostInternalServerError) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("nuid")
		e.Str(s.Nuid)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostReq = [2]string{
	0: "email",
	1: "nuid",
}

// Decode decodes APIV1MemberRegisterPostReq from json.
func (s *APIV1MemberRegisterPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "nuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Nuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostReq) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes GetInternalServerError from json.
func (s *GetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalServerError) {
					name = jsonFieldsNameOfGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthcheckGetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthcheckGetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfHealthcheckGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes HealthcheckGetInternalServerError from json.
func (s *HealthcheckGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthcheckGetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthcheckGetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthcheckGetInternalServerError) {
					name = jsonFieldsNameOfHealthcheckGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthcheckGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthcheckGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthcheckGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthcheckGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
}

var jsonFieldsNameOfHealthcheckGetOK = [1]string{
	0: "message",
}

// Decode decodes HealthcheckGetOK from json.
func (s *HealthcheckGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthcheckGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthcheckGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthcheckGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthcheckGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthcheckGetOKMessage as json.
func (s HealthcheckGetOKMessage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthcheckGetOKMessage from json.
func (s *HealthcheckGetOKMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthcheckGetOKMessage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthcheckGetOKMessage(v) {
	case HealthcheckGetOKMessageOK:
		*s = HealthcheckGetOKMessageOK
	default:
		*s = HealthcheckGetOKMessage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthcheckGetOKMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthcheckGetOKMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypes as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypes from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBoss as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesBoss) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBoss from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesBoss) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesBoss to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesBoss) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesBoss) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBossAtk as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesBossAtk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBossAtk from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesBossAtk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesBossAtk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesBossAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesBossAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBossHp as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesBossHp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBossHp from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesBossHp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesBossHp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesBossHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesBossHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesBossID as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesBossID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesBossID from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesBossID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesBossID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesBossID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesBossID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegular as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesRegular) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegular from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegular) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesRegular to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesRegular) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegular) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegularAtk from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularAtk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegularHp as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularHp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegularHp from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularHp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularHp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesRegularID as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesRegularID from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesRegularID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwift as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesSwift) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwift from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwift) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesSwift to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesSwift) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwift) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftHp from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftHp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftID as json.
func (o OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKAlienTypesSwiftID from json.
func (o *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKAlienTypesSwiftID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKBudget as json.
func (o OptAPIV1ChallengeIDAliensGetOKBudget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKBudget from json.
func (o *OptAPIV1ChallengeIDAliensGetOKBudget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKBudget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDAliensGetOKWallDurability as json.
func (o OptAPIV1ChallengeIDAliensGetOKWallDurability) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeIDAliensGetOKWallDurability from json.
func (o *OptAPIV1ChallengeIDAliensGetOKWallDurability) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDAliensGetOKWallDurability to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDAliensGetOKWallDurability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDAliensGetOKWallDurability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDSubmitPostReq as json.
func (o OptAPIV1ChallengeIDSubmitPostReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeIDSubmitPostReq from json.
func (o *OptAPIV1ChallengeIDSubmitPostReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDSubmitPostReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDSubmitPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDSubmitPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType as json.
func (o OptAPIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes APIV1ChallengeIDSubmitPostReqGunsPurchasedItemType from json.
func (o *OptAPIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeIDSubmitPostReqGunsPurchasedItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeIDSubmitPostReqGunsPurchasedItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1MemberRegisterPostReq as json.
func (o OptAPIV1MemberRegisterPostReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1MemberRegisterPostReq from json.
func (o *OptAPIV1MemberRegisterPostReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1MemberRegisterPostReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1MemberRegisterPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1MemberRegisterPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthcheckGetOKMessage as json.
func (o OptHealthcheckGetOKMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes HealthcheckGetOKMessage from json.
func (o *OptHealthcheckGetOKMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHealthcheckGetOKMessage to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHealthcheckGetOKMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHealthcheckGetOKMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
