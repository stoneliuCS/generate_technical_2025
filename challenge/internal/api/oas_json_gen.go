// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetInternalServerError from json.
func (s *APIV1ChallengeBackendIDAliensGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetInternalServerError) {
					name = jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetNotFound = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetNotFound from json.
func (s *APIV1ChallengeBackendIDAliensGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetNotFound) {
					name = jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOK) encodeFields(e *jx.Encoder) {
	{
		if s.Waves != nil {
			e.FieldStart("waves")
			e.ArrStart()
			for _, elem := range s.Waves {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AlienTypes.Set {
			e.FieldStart("alienTypes")
			s.AlienTypes.Encode(e)
		}
	}
	{
		if s.Budget.Set {
			e.FieldStart("budget")
			s.Budget.Encode(e)
		}
	}
	{
		if s.WallDurability.Set {
			e.FieldStart("wallDurability")
			s.WallDurability.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOK = [4]string{
	0: "waves",
	1: "alienTypes",
	2: "budget",
	3: "wallDurability",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOK from json.
func (s *APIV1ChallengeBackendIDAliensGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "waves":
			if err := func() error {
				s.Waves = make([]APIV1ChallengeBackendIDAliensGetOKWavesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeBackendIDAliensGetOKWavesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Waves = append(s.Waves, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"waves\"")
			}
		case "alienTypes":
			if err := func() error {
				s.AlienTypes.Reset()
				if err := s.AlienTypes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alienTypes\"")
			}
		case "budget":
			if err := func() error {
				s.Budget.Reset()
				if err := s.Budget.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"budget\"")
			}
		case "wallDurability":
			if err := func() error {
				s.WallDurability.Reset()
				if err := s.WallDurability.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wallDurability\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypes) encodeFields(e *jx.Encoder) {
	{
		if s.Regular.Set {
			e.FieldStart("regular")
			s.Regular.Encode(e)
		}
	}
	{
		if s.Swift.Set {
			e.FieldStart("swift")
			s.Swift.Encode(e)
		}
	}
	{
		if s.Boss.Set {
			e.FieldStart("boss")
			s.Boss.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKAlienTypes = [3]string{
	0: "regular",
	1: "swift",
	2: "boss",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypes from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "regular":
			if err := func() error {
				s.Regular.Reset()
				if err := s.Regular.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"regular\"")
			}
		case "swift":
			if err := func() error {
				s.Swift.Reset()
				if err := s.Swift.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swift\"")
			}
		case "boss":
			if err := func() error {
				s.Boss.Reset()
				if err := s.Boss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"boss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOKAlienTypes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) encodeFields(e *jx.Encoder) {
	{
		if s.Hp.Set {
			e.FieldStart("hp")
			s.Hp.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Atk.Set {
			e.FieldStart("atk")
			s.Atk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKAlienTypesBoss = [3]string{
	0: "hp",
	1: "id",
	2: "atk",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hp":
			if err := func() error {
				s.Hp.Reset()
				if err := s.Hp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "atk":
			if err := func() error {
				s.Atk.Reset()
				if err := s.Atk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) encodeFields(e *jx.Encoder) {
	{
		if s.Hp.Set {
			e.FieldStart("hp")
			s.Hp.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Atk.Set {
			e.FieldStart("atk")
			s.Atk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegular = [3]string{
	0: "hp",
	1: "id",
	2: "atk",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hp":
			if err := func() error {
				s.Hp.Reset()
				if err := s.Hp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "atk":
			if err := func() error {
				s.Atk.Reset()
				if err := s.Atk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) encodeFields(e *jx.Encoder) {
	{
		if s.Hp.Set {
			e.FieldStart("hp")
			s.Hp.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Atk.Set {
			e.FieldStart("atk")
			s.Atk.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwift = [3]string{
	0: "hp",
	1: "id",
	2: "atk",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hp":
			if err := func() error {
				s.Hp.Reset()
				if err := s.Hp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hp\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "atk":
			if err := func() error {
				s.Atk.Reset()
				if err := s.Atk.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"atk\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID as json.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID from json.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKBudget as json.
func (s APIV1ChallengeBackendIDAliensGetOKBudget) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKBudget from json.
func (s *APIV1ChallengeBackendIDAliensGetOKBudget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKBudget to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKBudget(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKWallDurability as json.
func (s APIV1ChallengeBackendIDAliensGetOKWallDurability) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKWallDurability from json.
func (s *APIV1ChallengeBackendIDAliensGetOKWallDurability) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKWallDurability to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = APIV1ChallengeBackendIDAliensGetOKWallDurability(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKWallDurability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWallDurability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItem) encodeFields(e *jx.Encoder) {
	{
		if s.Aliens != nil {
			e.FieldStart("aliens")
			e.ArrStart()
			for _, elem := range s.Aliens {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKWavesItem = [1]string{
	0: "aliens",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKWavesItem from json.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKWavesItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "aliens":
			if err := func() error {
				s.Aliens = make([]APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Aliens = append(s.Aliens, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"aliens\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOKWavesItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		e.FieldStart("count")
		e.Int(s.Count)
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem = [2]string{
	0: "type",
	1: "count",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem from json.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Count = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem) {
					name = jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType as json.
func (s APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType from json.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType(v) {
	case APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemTypeRegular:
		*s = APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemTypeRegular
	case APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemTypeSwift:
		*s = APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemTypeSwift
	case APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemTypeBoss:
		*s = APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemTypeBoss
	default:
		*s = APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetOKWavesItemAliensItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensGetUnauthorized) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetUnauthorized = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeBackendIDAliensGetUnauthorized from json.
func (s *APIV1ChallengeBackendIDAliensGetUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensGetUnauthorized to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensGetUnauthorized")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetUnauthorized) {
					name = jsonFieldsNameOfAPIV1ChallengeBackendIDAliensGetUnauthorized[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensGetUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensGetUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostBadRequest = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostBadRequest from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostBadRequest) {
					name = jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostInternalServerError from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostInternalServerError) {
					name = jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensSubmitPostOK as json.
func (s APIV1ChallengeBackendIDAliensSubmitPostOK) Encode(e *jx.Encoder) {
	switch s.Type {
	case APIV1ChallengeBackendIDAliensSubmitPostOK0APIV1ChallengeBackendIDAliensSubmitPostOK:
		s.APIV1ChallengeBackendIDAliensSubmitPostOK0.Encode(e)
	case APIV1ChallengeBackendIDAliensSubmitPostOK1APIV1ChallengeBackendIDAliensSubmitPostOK:
		s.APIV1ChallengeBackendIDAliensSubmitPostOK1.Encode(e)
	}
}

func (s APIV1ChallengeBackendIDAliensSubmitPostOK) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case APIV1ChallengeBackendIDAliensSubmitPostOK0APIV1ChallengeBackendIDAliensSubmitPostOK:
		s.APIV1ChallengeBackendIDAliensSubmitPostOK0.encodeFields(e)
	case APIV1ChallengeBackendIDAliensSubmitPostOK1APIV1ChallengeBackendIDAliensSubmitPostOK:
		s.APIV1ChallengeBackendIDAliensSubmitPostOK1.encodeFields(e)
	}
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostOK from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostOK to nil")
	}
	// Sum type fields.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			switch string(key) {
			case "score":
				match := APIV1ChallengeBackendIDAliensSubmitPostOK0APIV1ChallengeBackendIDAliensSubmitPostOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			case "reason":
				match := APIV1ChallengeBackendIDAliensSubmitPostOK1APIV1ChallengeBackendIDAliensSubmitPostOK
				if found && s.Type != match {
					s.Type = ""
					return errors.Errorf("multiple oneOf matches: (%v, %v)", s.Type, match)
				}
				found = true
				s.Type = match
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case APIV1ChallengeBackendIDAliensSubmitPostOK0APIV1ChallengeBackendIDAliensSubmitPostOK:
		if err := s.APIV1ChallengeBackendIDAliensSubmitPostOK0.Decode(d); err != nil {
			return err
		}
	case APIV1ChallengeBackendIDAliensSubmitPostOK1APIV1ChallengeBackendIDAliensSubmitPostOK:
		if err := s.APIV1ChallengeBackendIDAliensSubmitPostOK1.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensSubmitPostOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK0) encodeFields(e *jx.Encoder) {
	{
		if s.Valid.Set {
			e.FieldStart("valid")
			s.Valid.Encode(e)
		}
	}
	{
		if s.Score.Set {
			e.FieldStart("score")
			s.Score.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostOK0 = [2]string{
	0: "valid",
	1: "score",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostOK0 from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostOK0 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			if err := func() error {
				s.Valid.Reset()
				if err := s.Valid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "score":
			if err := func() error {
				s.Score.Reset()
				if err := s.Score.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"score\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostOK0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK1) encodeFields(e *jx.Encoder) {
	{
		if s.Valid.Set {
			e.FieldStart("valid")
			s.Valid.Encode(e)
		}
	}
	{
		if s.Reason.Set {
			e.FieldStart("reason")
			s.Reason.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostOK1 = [2]string{
	0: "valid",
	1: "reason",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostOK1 from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostOK1 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "valid":
			if err := func() error {
				s.Valid.Reset()
				if err := s.Valid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"valid\"")
			}
		case "reason":
			if err := func() error {
				s.Reason.Reset()
				if err := s.Reason.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reason\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostOK1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostOK1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReq) encodeFields(e *jx.Encoder) {
	{
		if s.GunsPurchased != nil {
			e.FieldStart("gunsPurchased")
			e.ArrStart()
			for _, elem := range s.GunsPurchased {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.TotalCost.Set {
			e.FieldStart("totalCost")
			s.TotalCost.Encode(e)
		}
	}
	{
		if s.Assignments != nil {
			e.FieldStart("assignments")
			e.ArrStart()
			for _, elem := range s.Assignments {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostReq = [3]string{
	0: "gunsPurchased",
	1: "totalCost",
	2: "assignments",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostReq from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "gunsPurchased":
			if err := func() error {
				s.GunsPurchased = make([]APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.GunsPurchased = append(s.GunsPurchased, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gunsPurchased\"")
			}
		case "totalCost":
			if err := func() error {
				s.TotalCost.Reset()
				if err := s.TotalCost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalCost\"")
			}
		case "assignments":
			if err := func() error {
				s.Assignments = make([]APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Assignments = append(s.Assignments, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"assignments\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Wave.Set {
			e.FieldStart("wave")
			s.Wave.Encode(e)
		}
	}
	{
		if s.GunQueues != nil {
			e.FieldStart("gunQueues")
			e.ArrStart()
			for _, elem := range s.GunQueues {
				e.ArrStart()
				for _, elem := range elem {
					e.Int(elem)
				}
				e.ArrEnd()
			}
			e.ArrEnd()
		}
	}
	{
		if s.WallDurabilityRemaining.Set {
			e.FieldStart("wallDurabilityRemaining")
			s.WallDurabilityRemaining.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem = [3]string{
	0: "wave",
	1: "gunQueues",
	2: "wallDurabilityRemaining",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "wave":
			if err := func() error {
				s.Wave.Reset()
				if err := s.Wave.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wave\"")
			}
		case "gunQueues":
			if err := func() error {
				s.GunQueues = make([][]int, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem []int
					elem = make([]int, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem int
						v, err := d.Int()
						elemElem = int(v)
						if err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					s.GunQueues = append(s.GunQueues, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gunQueues\"")
			}
		case "wallDurabilityRemaining":
			if err := func() error {
				s.WallDurabilityRemaining.Reset()
				if err := s.WallDurabilityRemaining.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wallDurabilityRemaining\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqAssignmentsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
}

var jsonFieldsNameOfAPIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem = [1]string{
	0: "type",
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType as json.
func (s APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType from json.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType(v) {
	case APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemTypeTurret:
		*s = APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemTypeTurret
	case APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemTypeMachineGun:
		*s = APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemTypeMachineGun
	case APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemTypeRayGun:
		*s = APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemTypeRayGun
	default:
		*s = APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberGetBadRequest = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberGetBadRequest from json.
func (s *APIV1MemberGetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetBadRequest) {
					name = jsonFieldsNameOfAPIV1MemberGetBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberGetInternalServerError from json.
func (s *APIV1MemberGetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetInternalServerError) {
					name = jsonFieldsNameOfAPIV1MemberGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetNotFound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberGetNotFound = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberGetNotFound from json.
func (s *APIV1MemberGetNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetNotFound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetNotFound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetNotFound) {
					name = jsonFieldsNameOfAPIV1MemberGetNotFound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfAPIV1MemberGetOK = [1]string{
	0: "id",
}

// Decode decodes APIV1MemberGetOK from json.
func (s *APIV1MemberGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberGetOK) {
					name = jsonFieldsNameOfAPIV1MemberGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostBadRequest) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostBadRequest = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberRegisterPostBadRequest from json.
func (s *APIV1MemberRegisterPostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostBadRequest to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostBadRequest")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostBadRequest) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostBadRequest[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostConflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostConflict) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostConflict = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberRegisterPostConflict from json.
func (s *APIV1MemberRegisterPostConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostConflict to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostConflict")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostConflict) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostConflict[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostCreated) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostCreated) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		json.EncodeUUID(e, s.ID)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostCreated = [1]string{
	0: "id",
}

// Decode decodes APIV1MemberRegisterPostCreated from json.
func (s *APIV1MemberRegisterPostCreated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostCreated to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostCreated")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostCreated) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostCreated[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostCreated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostCreated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostInternalServerError = [1]string{
	0: "message",
}

// Decode decodes APIV1MemberRegisterPostInternalServerError from json.
func (s *APIV1MemberRegisterPostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostInternalServerError) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *APIV1MemberRegisterPostReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *APIV1MemberRegisterPostReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
	{
		e.FieldStart("nuid")
		e.Str(s.Nuid)
	}
}

var jsonFieldsNameOfAPIV1MemberRegisterPostReq = [2]string{
	0: "email",
	1: "nuid",
}

// Decode decodes APIV1MemberRegisterPostReq from json.
func (s *APIV1MemberRegisterPostReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode APIV1MemberRegisterPostReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "email":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "nuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Nuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode APIV1MemberRegisterPostReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAPIV1MemberRegisterPostReq) {
					name = jsonFieldsNameOfAPIV1MemberRegisterPostReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *APIV1MemberRegisterPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *APIV1MemberRegisterPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		e.Str(s.Message)
	}
}

var jsonFieldsNameOfGetInternalServerError = [1]string{
	0: "message",
}

// Decode decodes GetInternalServerError from json.
func (s *GetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalServerError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Message = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalServerError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalServerError) {
					name = jsonFieldsNameOfGetInternalServerError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HealthcheckGetOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HealthcheckGetOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("message")
		s.Message.Encode(e)
	}
}

var jsonFieldsNameOfHealthcheckGetOK = [1]string{
	0: "message",
}

// Decode decodes HealthcheckGetOK from json.
func (s *HealthcheckGetOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthcheckGetOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HealthcheckGetOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHealthcheckGetOK) {
					name = jsonFieldsNameOfHealthcheckGetOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HealthcheckGetOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthcheckGetOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HealthcheckGetOKMessage as json.
func (s HealthcheckGetOKMessage) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HealthcheckGetOKMessage from json.
func (s *HealthcheckGetOKMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HealthcheckGetOKMessage to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HealthcheckGetOKMessage(v) {
	case HealthcheckGetOKMessageOK:
		*s = HealthcheckGetOKMessageOK
	default:
		*s = HealthcheckGetOKMessage(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HealthcheckGetOKMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HealthcheckGetOKMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypes as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypes from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBoss from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBoss to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBoss) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesBossID from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesBossID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegular from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegular to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegular) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesRegularID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwift from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwift to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwift) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftAtk) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftHp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKAlienTypesSwiftID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKBudget as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKBudget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKBudget from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKBudget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKBudget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKBudget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKBudget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensGetOKWallDurability as json.
func (o OptAPIV1ChallengeBackendIDAliensGetOKWallDurability) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensGetOKWallDurability from json.
func (o *OptAPIV1ChallengeBackendIDAliensGetOKWallDurability) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensGetOKWallDurability to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensGetOKWallDurability) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensGetOKWallDurability) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensSubmitPostReq as json.
func (o OptAPIV1ChallengeBackendIDAliensSubmitPostReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostReq from json.
func (o *OptAPIV1ChallengeBackendIDAliensSubmitPostReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensSubmitPostReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensSubmitPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensSubmitPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType as json.
func (o OptAPIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes APIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType from json.
func (o *OptAPIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1ChallengeBackendIDAliensSubmitPostReqGunsPurchasedItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes APIV1MemberRegisterPostReq as json.
func (o OptAPIV1MemberRegisterPostReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes APIV1MemberRegisterPostReq from json.
func (o *OptAPIV1MemberRegisterPostReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptAPIV1MemberRegisterPostReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptAPIV1MemberRegisterPostReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptAPIV1MemberRegisterPostReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
